{
  "repo_notes": [
    {
      "content": "ui8kit/core is a three-layered React UI component library built with utility-first classes and clean HTML5 semantic tag approach. The architecture consists of 3 levels: Core/UI (basic primitives), Components/UI (composite components), and Layouts (templates). This aligns with atomic design philosophy: atoms, molecules, and organisms. The library supports various integration formats: npm install, registry JSON, submodule to monorepo. Key features include: CVA-based (class-variance-authority) variant system and prop forwarding API for extended components. Important directories for documentation: src/core/ui/ (basic primitives), src/core/variants (CVA variants), src/components/ui/ (ready-made composite components), src/layouts/ (layout templates), src/components/GUIDE_CREATE_FORM.md (component development example where form components are absent and we use Block + Box instead), src/components/README.md (typical component usage examples). The library targets developers building React applications with Tailwind CSS. It supports modern patterns: compound components, render props, controlled/uncontrolled components. Documentation should cover all architecture levels: from basic primitives to complex layout components, explain the variant system, and demonstrate various integration and installation methods.",
      "author": "UI Systems Architect"
    },
    {
      "content": "Minimalism is the key motivation: complex interfaces can be built using just 15 composite components, and Tailwind flexibility fits into 12 reusable variants. This provides minimal code footprint, eliminates redundant classes, and enables unlimited design-flexible layouts.",
      "author": "Design Philosophy"
    },
    {
      "content": "The prop forwarding pattern allows extending base components with additional variant props from the core variant system. All components use consistent data-class attributes for identification and DOM targeting. Compound components pattern (Card.Header, Card.Content, Card.Footer) enables flexible composition while maintaining type safety.",
      "author": "Component Patterns"
    },
    {
      "content": "Integration scenarios include: standalone npm installation, per-component npm installation via npx buildy-ui add [component], JSON registry for programmatic access, git submodule for monorepo architectures, and direct source integration for custom builds.",
      "author": "Integration Formats"
    },
    {
      "content": "The variant system (CVA-based) centralizes styling logic: spacing (margin/padding), colors (backgrounds/text), layout (width/height), shadows, borders, rounded corners, typography, flexbox, and grid properties. Each variant is composable and reusable across components, reducing style duplication.",
      "author": "Variant System Architecture"
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "Introduction to the library, architectural principles, design philosophy, and core features",
      "page_notes": [
        {
          "content": "Explain the motivation behind creating this library: minimalism as the core principle. Demonstrate how complex interfaces can be built using just 15 composite components with 12 reusable variants that cover ~80% of design scenarios. Highlight how this approach minimizes code, eliminates excessive classes, and enables unlimited design flexibility in layouts."
        }
      ],
      "parent": null
    },
    {
      "title": "Getting Started",
      "purpose": "Installation and basic configuration of the library for various use cases",
      "page_notes": [
        {
          "content": "Base this section on the project's README file. Cover installation via npm, basic component imports, simple examples, and setup for different project types (Next.js, Vite, Create React App)."
        }
      ],
      "parent": null
    },
    {
      "title": "Architecture",
      "purpose": "Detailed description of the three-layered architecture: Core → Components → Layouts",
      "page_notes": [
        {
          "content": "Provide extensive examples and show component relationships and interactions. Explain architectural principles and implementation details. Note: API Reference has a dedicated section."
        }
      ],
      "parent": null
    },
    {
      "title": "Core Components",
      "purpose": "Documentation of basic primitives in src/core/ui/ and their composition",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "This section teaches fundamental React component principles: props, interfaces, imports/exports, element naming, and display configurations. Include beginner-friendly explanations of forwardRef, TypeScript types, and HTML attributes forwarding."
        }
      ]
    },
    {
      "title": "Variant System",
      "purpose": "Description of the CVA-based styling system (src/core/variants/): spacing, colors, layout, shadows, borders, etc.",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "This is a critical section. Explain how Tailwind utility classes are grouped by design concerns and made reusable across components. Cover fundamental principles, composition patterns, and interactions between variants. Show how this eliminates style duplication."
        }
      ]
    },
    {
      "title": "UI Components",
      "purpose": "Documentation of extended components in src/components/ui/ with prop forwarding API",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Explain core principles and how these components interact with variants. Cover the required data-class attribute usage and other prop configuration conventions. Show prop forwarding patterns and type safety."
        }
      ]
    },
    {
      "title": "Layouts",
      "purpose": "Documentation of layout components: DashLayout, LayoutBlock, SplitBlock, Grid, Flex",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Explain core principles and interactions with composite components. Cover special considerations for building structural layouts and component composition patterns."
        }
      ]
    },
    {
      "title": "Package Structure",
      "purpose": "Explain package.json configuration, distribution setup, and module exports",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Provide basic explanation of package configuration: entry points, exports, dependencies, dev dependencies, and how they support different integration formats."
        }
      ]
    },
    {
      "title": "Build System",
      "purpose": "Document the TypeScript compilation process, build scripts, and output generation",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Tutorial for configuring and compiling the library for dist/ output and NPM publication. Cover build commands, TypeScript configuration, output structure, and distribution files."
        }
      ]
    },
    {
      "title": "Component Registry",
      "purpose": "Explain the registry.json system, component metadata, and how it powers tooling",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Brief tutorial (to be expanded later). Explain principles for registering components and publishing to NPM so they're available via commands like `npx buildy-ui add button card`. Cover registry format and metadata."
        }
      ]
    },
    {
      "title": "TypeScript Configuration",
      "purpose": "Detail the TypeScript setup, path aliases, compilation targets, and type generation",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Detailed tutorial explaining TypeScript configuration: walk through each setting in tsconfig.json, explain path aliases, compilation targets, strict mode settings, and generated type definitions."
        }
      ]
    },
    {
      "title": "API Reference",
      "purpose": "Complete API documentation for component props, imported variants, consistent naming conventions, and export names",
      "parent": null
    },
    {
      "title": "Core Components",
      "purpose": "Complete API documentation for basic primitives (core/ui): Button, Card, Box, Grid, Stack, etc.",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Document each primitive component: props interface, TypeScript types, usage examples, and special attributes. Include forwardRef implementation details and ref typing."
        }
      ]
    },
    {
      "title": "UI Components",
      "purpose": "Complete API documentation for extended components (components/ui) with prop forwarding and variants",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Document each component: props interface, imported variants, TypeScript types, prop forwarding patterns, data-class attributes, usage examples, and extension capabilities."
        }
      ]
    },
    {
      "title": "Layout Components",
      "purpose": "API documentation for layout components and layout systems",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Explain component import scenarios, relationships, and structural layout construction patterns for different use cases: Landing Pages, Dashboards, Websites, Admin Panels. Show composition examples for each scenario."
        }
      ]
    },
    {
      "title": "Development Guide",
      "purpose": "Guide for contributors and developers working on the library",
      "parent": null,
      "page_notes": [
        {
          "content": "This section describes different usage scenarios adapted for MCP server integration. LLM will query this to understand how to use the library effectively. Include practical workflows and examples."
        }
      ]
    },
    {
      "title": "Basic Workflow",
      "purpose": "Common development patterns and usage examples for typical scenarios",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Base this on src/components/README.md. Show typical component usage examples for common development scenarios. Include step-by-step patterns developers follow."
        }
      ]
    },
    {
      "title": "Advanced Workflow",
      "purpose": "Handling edge cases where standard components are insufficient",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Cover non-standard scenarios where form components (Form, Label, Input) are absent. Show how to compose Block + Box for custom forms. Base this on src/components/GUIDE_CREATE_FORM.md."
        }
      ]
    },
    {
      "title": "Best Practices",
      "purpose": "General guidelines and recommendations for using components and building layouts",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Cover best practices, templates, and prototypes without relying on className or styles props (as variants and components cover ~80% of scenarios). Include recommendations for performance, accessibility, patterns, and semantic HTML usage."
        }
      ]
    },
    {
      "title": "Dark Mode",
      "purpose": "Explain dark mode implementation, toggle functionality, and persistence",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Instructions for configuring and applying dark mode. Base explanation on src/themes/providers/ThemeProvider.tsx. Cover the theme provider mechanism, hooks, preferences, and persistence."
        }
      ]
    },
    {
      "title": "Troubleshooting",
      "purpose": "Solutions for common problems, FAQ, and debugging guides",
      "parent": null
    }
  ]
}