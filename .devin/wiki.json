{
  "repo_notes": [
    {
      "content": "UI8Kit/core is a modern React UI component library built with a utility-first approach and clean semantic HTML. The architecture follows a three-layer system: Core/UI (basic primitives), Components/UI (composite components), and Layouts (page templates). This implements atomic design principles: atoms → molecules → organisms. The library supports multiple integration methods: npm install, component-specific installation via npx buildy-ui add [component], JSON registry for programmatic access, git submodule for monorepos, and direct source integration. Key features include: CVA (class-variance-authority) based variant system, prop forwarding API, polymorphic components, and full TypeScript support. Critical directories: src/components/ui/ (base primitives like Block, Box, Button), src/variants/ (CVA variant definitions), src/components/ (extended components), src/layouts/ (layout templates), GUIDE_CREATE_FORM.md (form creation guide using Block+Box since no Form components exist). The library targets React developers using Tailwind CSS, supporting modern patterns like compound components, controlled/uncontrolled inputs, and semantic HTML5.",
      "author": "UI Systems Architect"
    },
    {
      "content": "Minimalism drives the design: complex UIs can be built with just 15 composite components and 12 reusable variants covering ~80% of design scenarios. This provides minimal bundle size, eliminates redundant CSS classes, and enables unlimited design flexibility without sacrificing performance or developer experience.",
      "author": "Design Philosophy"
    },
    {
      "content": "Prop forwarding enables extending base components with variant props from the core system. All components include consistent data-class attributes for DOM targeting and testing. The compound component pattern (Card.Header, Card.Content, Card.Footer) provides flexible composition while maintaining full type safety and IntelliSense support.",
      "author": "Component Architecture"
    },
    {
      "content": "Integration options include: standard npm installation (@ui8kit/core), per-component installation (npx buildy-ui add button), JSON registry for programmatic component discovery, git submodule for monorepo integration, and direct source imports for advanced customization. Each method supports tree shaking and optimal bundle sizes.",
      "author": "Integration Methods"
    },
    {
      "content": "The CVA-based variant system centralizes styling logic across: spacing (p, m, gap), colors (bg, c, border), layout (w, h, display), visual effects (shadow, rounded, border), typography (size, weight, align), and component-specific variants (button styles, badge variants). Variants are composable, reusable, and automatically merged to prevent conflicts.",
      "author": "Variant System"
    },
    {
      "content": "UI8Kit uses zero-runtime styling: all variants compile to Tailwind classes at build time. The library achieves ~15KB gzipped bundle size through aggressive tree shaking. Components support full TypeScript with generated types, polymorphic rendering (any HTML element via component prop), and semantic data-class attributes for reliable testing and styling.",
      "author": "Performance & DX"
    },
    {
      "content": "Key components: Block (polymorphic container), Box (flexible primitive), Button (interactive with variants), Card (compound structure), Container (responsive wrapper), Stack/Group (flex layouts), Grid (CSS Grid), Title/Text (typography), Image/Icon (media). All support universal props: spacing, colors, layout, shadows, borders, and component-specific variants.",
      "author": "Core Components"
    },
    {
      "content": "No dedicated form components exist - use Block+Box composition for forms. Example: Block as form container, Box as input/textarea with proper ARIA labels. This approach provides maximum flexibility while maintaining consistent styling and behavior.",
      "author": "Form Handling"
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "Library introduction, architectural principles, design philosophy, and key features",
      "page_notes": [
        {
          "content": "Explain UI8Kit's minimalist approach: build complex UIs with 15 composite components and 12 variants covering 80% of design needs. Demonstrate zero-runtime styling, tree shaking benefits, and how the utility-first approach with semantic classes eliminates redundant CSS while maintaining full design flexibility."
        }
      ],
      "parent": null
    },
    {
      "title": "Getting Started",
      "purpose": "Installation, configuration, and basic usage for different project setups",
      "page_notes": [
        {
          "content": "Cover npm installation, Tailwind setup, CSS variables configuration, theme provider setup, and basic component usage. Include examples for Vite, Next.js, and Create React App. Emphasize the importance of content paths in Tailwind config for proper styling."
        }
      ],
      "parent": null
    },
    {
      "title": "Architecture",
      "purpose": "Three-layer architecture explanation: Core primitives → Composite components → Layout templates",
      "page_notes": [
        {
          "content": "Detail the Core/UI layer (Block, Box, Button), Components/UI layer (extended components with variants), and Layouts layer (page templates). Explain CVA variant system, prop forwarding, polymorphic components, and how everything ties together for maximum composability."
        }
      ],
      "parent": null
    },
    {
      "title": "Core Components",
      "purpose": "Basic primitives documentation: Block, Box, Button, and their fundamental APIs",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Cover the essential building blocks: Block (polymorphic container), Box (universal primitive), Button (interactive element). Explain prop forwarding, component prop for polymorphism, TypeScript interfaces, and how these primitives form the foundation for all other components."
        }
      ]
    },
    {
      "title": "Variant System",
      "purpose": "CVA-based styling system explanation: spacing, colors, layout, typography, and component variants",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Critical section explaining how variants work: spacing (p, m, gap), colors (bg, c), layout (w, h, display), visual (shadow, rounded), and component-specific variants. Show how variants compose, how Tailwind merging works, and how to create custom variants."
        }
      ]
    },
    {
      "title": "UI Components",
      "purpose": "Extended components with full variant support: Card, Badge, Title, Text, Image, etc.",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Document composite components that extend primitives with specific functionality. Explain compound component patterns (Card.Header), data-class attributes for testing, and how these components provide high-level APIs while maintaining the flexibility of the variant system."
        }
      ]
    },
    {
      "title": "Layout Components",
      "purpose": "Layout and structural components: Container, Stack, Group, Grid",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Cover layout primitives for building page structures. Explain Container (responsive wrapper), Stack/Group (flex layouts), Grid (CSS Grid with responsive presets). Show how these create consistent spacing and alignment across applications."
        }
      ]
    },
    {
      "title": "Package Structure",
      "purpose": "Explain package.json configuration, distribution setup, and module exports",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Provide basic explanation of package configuration: entry points, exports, dependencies, dev dependencies, and how they support different integration formats."
        }
      ]
    },
    {
      "title": "Build System",
      "purpose": "Document the TypeScript compilation process, build scripts, and output generation",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Tutorial for configuring and compiling the library for dist/ output and NPM publication. Cover build commands, TypeScript configuration, output structure, and distribution files."
        }
      ]
    },
    {
      "title": "Component Registry",
      "purpose": "Explain the registry.json system, component metadata, and how it powers tooling",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Brief tutorial (to be expanded later). Explain principles for registering components and publishing to NPM so they're available via commands like `npx buildy-ui add button card`. Cover registry format and metadata."
        }
      ]
    },
    {
      "title": "TypeScript Configuration",
      "purpose": "Detail the TypeScript setup, path aliases, compilation targets, and type generation",
      "parent": "Architecture",
      "page_notes": [
        {
          "content": "Detailed tutorial explaining TypeScript configuration: walk through each setting in tsconfig.json, explain path aliases, compilation targets, strict mode settings, and generated type definitions."
        }
      ]
    },
    {
      "title": "API Reference",
      "purpose": "Complete component API documentation: props, types, variants, and usage patterns",
      "parent": null
    },
    {
      "title": "Core Components",
      "purpose": "API documentation for basic primitives: Block, Box, Button with TypeScript interfaces and examples",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Detail Block (polymorphic container), Box (universal primitive), Button (interactive element). Include complete prop interfaces, TypeScript types, forwardRef patterns, component polymorphism, and practical usage examples with different HTML elements."
        }
      ]
    },
    {
      "title": "UI Components",
      "purpose": "API documentation for extended components: Card, Badge, Title, Text, Image with variant support",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Document composite components with full variant APIs. Cover compound patterns (Card.Header), data-class attributes, prop forwarding, and how components extend base primitives while maintaining type safety and flexibility."
        }
      ]
    },
    {
      "title": "Layout Components",
      "purpose": "API documentation for layout system: Container, Stack, Group, Grid with responsive patterns",
      "parent": "API Reference",
      "page_notes": [
        {
          "content": "Explain layout components for building page structures. Cover Container sizing, Stack/Group flex layouts, Grid responsive presets. Show how these components create consistent spacing, alignment, and responsive behavior across different screen sizes."
        }
      ]
    },
    {
      "title": "Development Guide",
      "purpose": "Developer workflows, best practices, and advanced usage patterns",
      "parent": null,
      "page_notes": [
        {
          "content": "Comprehensive guide for UI8Kit developers. Covers component composition, theme customization, performance optimization, and real-world usage patterns. Includes practical examples for common development scenarios."
        }
      ]
    },
    {
      "title": "Basic Workflow",
      "purpose": "Step-by-step development workflow from project setup to deployment",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Complete workflow guide: project creation, theme setup, component development, testing, and deployment. Includes Tailwind configuration, CSS variables setup, theme provider integration, and common development patterns."
        }
      ]
    },
    {
      "title": "Component Development",
      "purpose": "Creating custom components and extending UI8Kit with new functionality",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Guide for building custom components that integrate with UI8Kit's variant system. Covers extending base components, creating new variants, prop forwarding patterns, and maintaining consistency with the design system."
        }
      ]
    },
    {
      "title": "Best Practices",
      "purpose": "Guidelines for optimal component usage, performance, and maintainability",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Best practices for UI8Kit usage: semantic HTML, accessibility, performance optimization, TypeScript patterns, theming approaches. Emphasizes the utility-first philosophy and avoiding custom CSS when variants suffice."
        }
      ]
    },
    {
      "title": "Dark Mode",
      "purpose": "Complete dark mode implementation with theme switching and persistence",
      "parent": "Development Guide",
      "page_notes": [
        {
          "content": "Detailed guide for implementing dark mode: CSS variable setup, ThemeProvider configuration, toggle components, system preference detection, localStorage persistence, and theme switching animations."
        }
      ]
    },
    {
      "title": "Troubleshooting",
      "purpose": "Common issues, debugging techniques, and problem-solving guides",
      "parent": null,
      "page_notes": [
        {
          "content": "Comprehensive troubleshooting guide covering: component styling issues, TypeScript errors, theme problems, form handling, responsive design, accessibility concerns, and performance optimization. Includes diagnostic steps and solutions."
        }
      ]
    }
  ]
}